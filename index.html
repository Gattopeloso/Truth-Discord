<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Truth or Dare — Group (18+)</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
<style>
.player-name {
  color: #ef4444;
  font-weight: 600;
}

:root {
  --bg-top: #050816;
  --bg-bottom: #131b2c;
  --fg: #e2e8f0;
  --muted: rgba(148, 163, 184, 0.78);
  --accent: linear-gradient(135deg, #6366f1, #22d3ee);
  --accent-solid: #22d3ee;
  --accent2: linear-gradient(135deg, #f97316, #ef4444);
  --accent2-solid: #ef4444;
  --accent3: linear-gradient(135deg, #facc15, #f97316);
  --card: rgba(15, 23, 42, 0.86);
  --card-border: rgba(148, 163, 184, 0.18);
  --shadow: 0 30px 80px rgba(5, 6, 25, 0.75);
  --surface: rgba(30, 41, 59, 0.85);
  --surface-muted: rgba(51, 65, 85, 0.6);
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
}

body {
  margin: 0;
  background: radial-gradient(circle at top left, rgba(99, 102, 241, 0.35), transparent 55%),
    radial-gradient(circle at bottom right, rgba(236, 72, 153, 0.28), transparent 45%),
    linear-gradient(160deg, var(--bg-top), var(--bg-bottom));
  color: var(--fg);
  font-family: "Fredoka", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans",
    "Apple Color Emoji", "Segoe UI Emoji";
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  position: relative;
  overflow-x: hidden;
}

body::before,
body::after {
  content: "";
  position: fixed;
  width: 420px;
  height: 420px;
  border-radius: 999px;
  filter: blur(0);
  opacity: 0.32;
  z-index: 0;
  pointer-events: none;
}

body::before {
  background: radial-gradient(circle at center, rgba(59, 130, 246, 0.35), rgba(59, 130, 246, 0));
  top: -120px;
  left: -140px;
}

body::after {
  background: radial-gradient(circle at center, rgba(190, 24, 93, 0.35), rgba(190, 24, 93, 0));
  bottom: -160px;
  right: -140px;
}

header {
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  align-items: flex-start;
  padding: 1.75rem clamp(1.5rem, 4vw, 4rem) 0;
}

.topbar-buttons {
  display: flex;
  gap: 0.65rem;
  flex-wrap: wrap;
}

.session-status {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
  font-size: 0.95rem;
  color: rgba(226, 232, 240, 0.8);
}

.role-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.25rem 0.9rem;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.32);
  background: rgba(15, 23, 42, 0.68);
  color: rgba(226, 232, 240, 0.92);
  font-weight: 600;
  letter-spacing: 0.02em;
}

.menu-toggle {
  padding: 0.5rem 1.1rem;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.3);
  background: rgba(15, 23, 42, 0.65);
  color: var(--fg);
  font-weight: 600;
  font-size: 0.9rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
}

.menu-toggle:hover,
.menu-toggle:focus-visible {
  background: rgba(59, 130, 246, 0.32);
  border-color: rgba(96, 165, 250, 0.5);
  transform: translateY(-1px);
}

.menu-toggle[aria-expanded="true"] {
  background: rgba(59, 130, 246, 0.45);
  border-color: rgba(96, 165, 250, 0.7);
}

.menu-toggle[disabled] {
  opacity: 0.45;
  cursor: not-allowed;
  pointer-events: none;
}

.join-btn {
  background: linear-gradient(135deg, rgba(45, 212, 191, 0.92), rgba(14, 165, 233, 0.92));
  border: none;
  color: #0f172a;
  font-weight: 700;
}

.join-btn:hover,
.join-btn:focus-visible {
  background: linear-gradient(135deg, rgba(34, 197, 94, 0.95), rgba(6, 182, 212, 0.95));
  color: #0b1120;
}

.join-btn[disabled] {
  opacity: 0.55;
  color: rgba(15, 23, 42, 0.6);
  cursor: not-allowed;
  pointer-events: none;
}

.overlay-menu {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: clamp(1rem, 4vw, 3rem);
  background: rgba(2, 6, 23, 0.68);
  backdrop-filter: blur(14px);
  z-index: 4;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.24s ease, visibility 0.24s ease;
  overflow-y: auto;
}

.overlay-menu.open {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
}

.overlay-menu .control-panel {
  transform: translateY(12px);
  opacity: 0;
  transition: transform 0.26s ease, opacity 0.26s ease;
}

.overlay-menu.open .control-panel {
  transform: translateY(0);
  opacity: 1;
}

.control-panel {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  align-items: flex-start;
  background: var(--surface);
  border: 1px solid var(--card-border);
  border-radius: 24px;
  padding: 2.2rem 1.75rem 1.75rem;
  box-shadow: 0 24px 60px rgba(2, 6, 23, 0.65);
  backdrop-filter: blur(12px);
  position: relative;
  width: min(640px, 100%);
}

.overlay-close {
  position: absolute;
  top: 0.9rem;
  right: 1rem;
  border: none;
  background: rgba(15, 23, 42, 0.55);
  color: var(--fg);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 1.1rem;
  transition: background 0.2s ease, transform 0.2s ease;
}

.overlay-close:hover,
.overlay-close:focus-visible {
  background: rgba(59, 130, 246, 0.45);
  transform: translateY(-1px);
}

.player-manager {
  flex: 1 1 280px;
  min-width: min(320px, 100%);
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}

.overlay-title {
  font-size: 1.35rem;
  font-weight: 700;
  color: var(--fg);
  margin: 0 0 0.75rem;
  letter-spacing: 0.3px;
  flex-basis: 100%;
}

.categories-panel {
  flex-wrap: nowrap;
  flex-direction: column;
  align-items: stretch;
  width: min(760px, 100%);
  gap: 1.25rem;
  padding: 2.3rem 2rem 2.25rem;
  max-height: min(78vh, 640px);
  overflow-y: auto;
}

.rewind-panel {
  width: min(520px, 100%);
  gap: 1.5rem;
  padding: clamp(2rem, 4vw, 2.75rem);
}

.rewind-content {
  display: flex;
  flex-direction: column;
  gap: 1.1rem;
  width: 100%;
}

.rewind-meta {
  margin: 0;
  font-size: clamp(0.95rem, 1.6vw, 1.15rem);
  color: rgba(226, 232, 240, 0.82);
}

.rewind-meta strong {
  color: #fff;
  margin-right: 0.3rem;
}

.rewind-players {
  display: inline-flex;
  flex-wrap: wrap;
  gap: 0.35rem;
}

.rewind-players span {
  background: rgba(15, 23, 42, 0.55);
  border-radius: 999px;
  padding: 0.25rem 0.65rem;
  font-weight: 600;
  color: #f8fafc;
}

.rewind-question {
  margin: 0;
  font-size: clamp(1rem, 2vw, 1.45rem);
  line-height: 1.55;
  color: #f8fafc;
  background: rgba(15, 23, 42, 0.6);
  border-radius: 20px;
  padding: clamp(1rem, 3vw, 1.5rem);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.2);
}

.rewind-empty {
  margin: 0;
  font-size: clamp(1rem, 1.8vw, 1.3rem);
  text-align: center;
  color: rgba(226, 232, 240, 0.82);
}

.player-input {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  flex: 1 1 auto;
}

.setup-actions {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  width: 100%;
  flex-wrap: wrap;
}

.row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.btn {
  font-size: 1.05rem;
  padding: 0.75rem 1.4rem;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-weight: 700;
  color: #fff;
  position: relative;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.btn::after {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.15);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.btn[disabled],
.btn.is-disabled {
  opacity: 0.6;
  cursor: not-allowed;
  box-shadow: none;
  pointer-events: none;
}

.btn[disabled]::after,
.btn.is-disabled::after {
  opacity: 0;
}

.btn:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 12px 28px rgba(2, 6, 23, 0.65);
}

.btn:hover::after {
  opacity: 1;
}

#startBtn {
  background: var(--accent);
}

.setup-actions #startBtn {
  flex: 0 0 auto;
}

.setup-actions .player-input {
  flex: 1 1 240px;
}

#playersInput {
  padding: 0.75rem 1rem;
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.25);
  background: var(--surface-muted);
  color: var(--fg);
  width: 100%;
  font-size: 1rem;
  transition: box-shadow 0.2s ease, transform 0.2s ease;
}

#playersInput::placeholder {
  color: rgba(226, 232, 240, 0.6);
}

#playersInput:focus {
  outline: none;
  box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.4);
  transform: translateY(-1px);
}

.ghost-btn {
  background: transparent;
  border: none;
  color: rgba(226, 232, 240, 0.78);
  font-weight: 600;
  font-size: 0.9rem;
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  cursor: pointer;
  align-self: flex-start;
  padding: 0;
  transition: color 0.2s ease;
}

.ghost-btn:hover {
  color: rgba(255, 255, 255, 0.95);
  text-decoration: underline;
}

#playersList {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.player-chip {
  border: none;
  border-radius: 999px;
  padding: 0.45rem 0.85rem;
  background: rgba(15, 23, 42, 0.75);
  box-shadow: 0 10px 24px rgba(2, 6, 23, 0.55);
  font-weight: 600;
  font-size: 0.95rem;
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  color: var(--fg);
  cursor: pointer;
  transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
}

.player-chip:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 28px rgba(8, 11, 38, 0.75);
  background: rgba(30, 64, 175, 0.9);
}

.player-chip.is-host {
  border: 1px solid rgba(250, 204, 21, 0.65);
  background: linear-gradient(135deg, rgba(250, 204, 21, 0.18), rgba(245, 158, 11, 0.18));
  color: #fef3c7;
}

.player-chip.is-self {
  border: 1px solid rgba(59, 130, 246, 0.65);
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.16), rgba(96, 165, 250, 0.16));
}

.player-chip[disabled] {
  cursor: default;
  opacity: 0.7;
  pointer-events: none;
}

.player-chip span.remove {
  font-size: 1.1rem;
  line-height: 1;
}

#voiceSelect {
  padding: 0.6rem 0.9rem;
  border-radius: 14px;
  border: 1px solid rgba(148, 163, 184, 0.25);
  background: rgba(15, 23, 42, 0.8);
  color: var(--fg);
  min-width: 180px;
}

#playersMessage {
  display: block;
  margin: 0;
  font-size: 0.95rem;
  color: rgba(226, 232, 240, 0.76);
  padding: 0 0.35rem;
}

main {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: clamp(1.5rem, 4vw, 4.5rem);
  position: relative;
  z-index: 1;
}

.stage {
  width: 100%;
  margin: 0 auto;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: stretch;
  gap: clamp(1.5rem, 4vw, 3.5rem);
  flex-wrap: wrap;
}

.stage::before,
.stage::after {
  content: "";
  position: absolute;
  border-radius: 50%;
  filter: blur(0);
  opacity: 0.25;
  z-index: -1;
  pointer-events: none;
}

.stage::before {
  width: 320px;
  height: 320px;
  background: radial-gradient(circle, rgba(14, 165, 233, 0.35), rgba(14, 165, 233, 0));
  top: -110px;
  left: -120px;
}

.stage::after {
  width: 260px;
  height: 260px;
  background: radial-gradient(circle, rgba(244, 63, 94, 0.35), rgba(244, 63, 94, 0));
  bottom: -80px;
  right: -90px;
}

.game-card {
  flex: 1 1 100%;
  width: 100%;
  max-width: 100%;
  min-width: 0;
  background: var(--card);
  border-radius: 32px;
  padding: clamp(1.8rem, 4vw, 3.5rem);
  box-shadow: var(--shadow);
  backdrop-filter: blur(12px);
  border: 1px solid var(--card-border);
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 1rem;
  position: relative;
  overflow: hidden;
}

.game-card::before {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0));
  pointer-events: none;
}

.badge-row {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
}

.cycle-pill {
  background: rgba(148, 163, 184, 0.18);
  color: #e0f2fe;
  border-radius: 999px;
  padding: 0.45rem 1rem;
  font-size: 0.95rem;
  font-weight: 600;
  text-align: center;
  min-height: 2.3rem;
  display: flex;
  flex-direction: column;
  gap: 0.15rem;
  align-items: center;
  justify-content: center;
  line-height: 1.3;
  flex: 1;
}

#category {
  font-size: clamp(0.95rem, 1.9vw, 1.5rem);
  color: rgba(226, 232, 240, 0.72);
  font-weight: 600;
  letter-spacing: 0.2px;
  text-align: center;
  margin: 0 auto;
}

#question {
  font-size: clamp(1.5rem, 3vw, 3.8rem);
  line-height: 1.3;
  font-weight: 600;
  letter-spacing: 0.22px;
  text-align: center;
  margin: 0 auto;
  width: 100%;
  max-width: 100%;
  min-height: clamp(220px, 34vh, 440px);
  padding: clamp(0.75rem, 2.4vw, 1.6rem) clamp(1.2rem, 3.8vw, 2.8rem);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  gap: clamp(0.18rem, 0.6vw, 0.35rem);
  align-content: center;
  align-self: stretch;
  flex: 1 1 auto;
  height: 100%;
  text-wrap: balance;
}

.question-word {
  display: inline-flex;
  overflow: hidden;
  vertical-align: bottom;
}

.question-word-inner {
  display: inline-block;
  will-change: transform;
  transform: translateY(0%);
}

.action-cluster {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: clamp(0.75rem, 2vw, 1.35rem);
  margin-top: clamp(1.1rem, 2.4vw, 1.8rem);
  padding-top: clamp(1rem, 2vw, 1.6rem);
  border-top: 1px solid rgba(255, 255, 255, 0.08);
}

.action-cluster[hidden] {
  display: none;
}

.btn.action-btn {
  display: none;
  align-items: center;
  justify-content: center;
  padding: clamp(0.95rem, 2.4vw, 1.3rem) clamp(2.4rem, 4.6vw, 3.4rem);
  border: none;
  border-radius: 28px;
  font-family: "Fredoka", sans-serif;
  font-weight: 600;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: #0f172a;
  background-size: 200% 200%;
  font-size: clamp(0.95rem, 2vw, 1.25rem);
  box-shadow: 0 10px 24px rgba(2, 6, 23, 0.5), inset 0 0 6px rgba(255, 255, 255, 0.08);
  transition: transform 0.24s ease, box-shadow 0.24s ease, background-position 0.4s ease;
  cursor: pointer;
  min-width: clamp(170px, 22vw, 260px);
}

.btn.action-btn:focus-visible {
  outline: 3px solid rgba(99, 102, 241, 0.55);
  outline-offset: 3px;
}

.btn.action-btn:hover {
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 14px 36px rgba(99, 102, 241, 0.55), 0 0 12px rgba(99, 102, 241, 0.6);
  background-position: 100% 0;
}

.btn.action-btn:active {
  transform: scale(0.97);
  box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
}

#nextBtn {
  background: linear-gradient(135deg, #22d3ee, #6366f1);
  color: #ffffff;
  font-size: clamp(1.05rem, 2.4vw, 1.55rem);
  letter-spacing: 0.18em;
  min-width: clamp(200px, 26vw, 280px);
  min-height: clamp(90px, 13vw, 140px);
}

#skipBtn {
  background: linear-gradient(135deg, #f97316, #ef4444);
  color: #ffffff;
  letter-spacing: 0.16em;
  min-width: clamp(190px, 24vw, 260px);
  min-height: clamp(84px, 12vw, 128px);
}

#speakBtn {
  background: linear-gradient(135deg, #3b82f6, #8b5cf6);
  color: #ffffff;
  padding: 0;
  min-width: clamp(70px, 8vw, 96px);
  width: clamp(70px, 8vw, 96px);
  height: clamp(70px, 8vw, 96px);
  letter-spacing: 0;
  font-size: clamp(1.2rem, 2.4vw, 1.8rem);
}

#stopSpeakBtn {
  background: linear-gradient(135deg, #a5b4fc, #c7d2fe);
  color: #0f172a;
  padding: 0;
  min-width: clamp(70px, 8vw, 96px);
  width: clamp(70px, 8vw, 96px);
  height: clamp(70px, 8vw, 96px);
  letter-spacing: 0;
  font-size: clamp(1.2rem, 2.4vw, 1.8rem);
}

#sections {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 0.75rem;
}

.chip {
  background: rgba(30, 41, 59, 0.85);
  border: 1px solid rgba(148, 163, 184, 0.18);
  color: var(--fg);
  padding: 0.55rem 1.15rem;
  border-radius: 999px;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 600;
  box-shadow: 0 12px 26px rgba(8, 11, 38, 0.55);
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}

.chip:disabled {
  opacity: 0.55;
  cursor: not-allowed;
  pointer-events: none;
}

.chip:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 32px rgba(15, 23, 42, 0.8);
}

.chip[data-enabled="true"] {
  background: linear-gradient(135deg, rgba(6, 182, 212, 0.9), rgba(37, 99, 235, 0.9));
  color: #fff;
}

.chip[data-enabled="false"] {
  background: linear-gradient(135deg, rgba(234, 179, 8, 0.9), rgba(248, 113, 113, 0.9));
  color: #fff;
}

.audio-settings {
  display: flex;
  flex-direction: column;
  gap: 0.85rem;
  width: 100%;
  align-items: flex-start;
}

#voiceWrapper {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

#toggleVoice {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: rgba(34, 211, 238, 0.2);
  font-size: 1.5rem;
  transition: transform 0.2s ease;
}

#toggleVoice:hover {
  transform: rotate(-8deg) scale(1.05);
}

.auto-speak-toggle {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.65rem 0.95rem;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.26);
  color: rgba(226, 232, 240, 0.86);
  font-weight: 600;
  cursor: pointer;
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
  width: fit-content;
}

.auto-speak-toggle:hover {
  border-color: rgba(148, 163, 184, 0.45);
  background: rgba(30, 41, 59, 0.75);
  box-shadow: 0 12px 28px rgba(2, 6, 23, 0.45);
}

.auto-speak-toggle.is-active {
  border-color: rgba(148, 163, 184, 0.55);
  background: rgba(59, 130, 246, 0.28);
  box-shadow: 0 16px 32px rgba(37, 99, 235, 0.25);
}

.auto-speak-toggle input {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

.auto-speak-toggle .switch {
  position: relative;
  width: 54px;
  height: 28px;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.35);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.35);
  transition: background 0.22s ease, box-shadow 0.22s ease;
}

.auto-speak-toggle .switch::after {
  content: "";
  position: absolute;
  top: 4px;
  left: 4px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #f8fafc;
  box-shadow: 0 6px 16px rgba(15, 23, 42, 0.55);
  transition: transform 0.22s ease;
}

.auto-speak-toggle input:focus-visible + .switch {
  box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.45);
}

.auto-speak-toggle input:checked + .switch {
  background: linear-gradient(135deg, #3b82f6, #8b5cf6);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.22);
}

.auto-speak-toggle input:checked + .switch::after {
  transform: translateX(26px);
}

.auto-speak-toggle .toggle-text {
  font-size: 0.95rem;
  letter-spacing: 0.2px;
  color: rgba(226, 232, 240, 0.9);
}

.auto-speak-toggle input:checked ~ .toggle-text {
  color: #ffffff;
}

.count {
  display: inline-block;
  margin-left: 0.25rem;
  font-size: 0.85rem;
  color: rgba(148, 163, 184, 0.7);
}


.small {
  font-size: 0.85rem;
  color: rgba(148, 163, 184, 0.68);
}

@media (max-width: 720px) {
  .menu-toggle {
    width: 100%;
    justify-content: center;
  }

  .control-panel {
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    padding: 2rem 1.35rem 1.6rem;
  }

  .player-manager {
    width: 100%;
  }

  .player-input {
    flex-direction: column;
    align-items: stretch;
  }

  #playersInput {
    width: 100%;
  }

  #voiceSelect {
    width: 100%;
  }

  #playersList {
    justify-content: flex-start;
  }

  .badge-row {
    flex-direction: column;
    align-items: stretch;
  }

  .cycle-pill {
    width: 100%;
  }

  .auto-speak-toggle {
    width: 100%;
    justify-content: flex-start;
  }

  .stage {
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .action-cluster {
    justify-content: center;
    gap: clamp(0.75rem, 3vw, 1.2rem);
    padding-top: 1rem;
  }

  .btn.action-btn {
    flex: 1 1 calc(50% - clamp(0.75rem, 3vw, 1.1rem));
    min-width: calc(50% - clamp(0.75rem, 3vw, 1.1rem));
    max-width: calc(50% - clamp(0.75rem, 3vw, 1.1rem));
  }

  #speakBtn,
  #stopSpeakBtn {
    width: 100%;
    height: clamp(64px, 18vw, 88px);
    font-size: clamp(1.05rem, 4vw, 1.45rem);
  }
}

@media (min-width: 1080px) {
  .stage {
    flex-wrap: nowrap;
    justify-content: center;
    gap: clamp(2rem, 4vw, 4rem);
  }

  .game-card {
    flex: 1 1 100%;
  }
}

@media (min-width: 1440px) {
  main {
    padding: clamp(3rem, 6vw, 6.5rem);
  }

  .stage {
    max-width: 100%;
    gap: clamp(2.5rem, 5vw, 5rem);
  }
}
</style>
</head>
<body>
  <header>
    <div class="topbar-buttons">
      <button
        id="setupToggle"
        class="menu-toggle"
        type="button"
        aria-controls="setupOverlay"
        aria-haspopup="dialog"
        aria-expanded="false"
      >
        Game setup
      </button>
      <button
        id="categoriesToggle"
        class="menu-toggle"
        type="button"
        aria-controls="categoriesOverlay"
        aria-haspopup="dialog"
        aria-expanded="false"
      >
        Categories
      </button>
      <button
        id="rewindToggle"
        class="menu-toggle"
        type="button"
        aria-controls="rewindOverlay"
        aria-haspopup="dialog"
        aria-expanded="false"
      >
        Rewind
      </button>
      <button id="joinPlayerBtn" class="menu-toggle join-btn" type="button">Join as Player</button>
    </div>
    <div class="session-status" aria-live="polite">
      <span id="roleStatus" class="role-badge">Connecting…</span>
    </div>
    <span id="playersMessage" aria-live="polite"></span>
  </header>

  <main>
    <div class="stage">
      <div class="game-card">
        <div class="badge-row">
          <div id="cycle_players" class="cycle-pill"></div>
        </div>
        <div id="category">✨ Press START to kick things off</div>
        <div id="question">Add anyone you want to the crew and press START to draw a sparkling challenge.</div>
        <div class="action-cluster" id="actionCluster" hidden aria-label="Question controls">
          <button id="speakBtn" class="btn action-btn" type="button" aria-label="Play question audio">🔊</button>
          <button id="stopSpeakBtn" class="btn action-btn" type="button" aria-label="Stop question audio">⏹️</button>
          <button id="skipBtn" class="btn action-btn" type="button">SKIP</button>
          <button id="nextBtn" class="btn action-btn" type="button">NEXT</button>
        </div>
      </div>
    </div>
    <div
      id="setupOverlay"
      class="overlay-menu"
      aria-hidden="true"
    >
      <div
        class="control-panel"
        id="controlPanel"
        role="dialog"
        aria-modal="true"
        aria-labelledby="setupTitle"
        tabindex="-1"
      >
        <button id="closeSetupBtn" class="overlay-close" type="button" aria-label="Close setup panel">✕</button>
        <h2 class="overlay-title" id="setupTitle">Game setup</h2>
        <div class="player-manager">
          <div class="setup-actions">
            <button id="startBtn" class="btn">START</button>
            <div class="player-input">
              <input
                id="playersInput"
                type="text"
                placeholder="Add player names (press Enter or use commas)"
                aria-label="Add player names"
              />
            </div>
          </div>
          <div id="playersList" aria-live="polite" role="list"></div>
          <button id="clearPlayersBtn" class="ghost-btn" type="button">Clear all players</button>
        </div>
        <div class="audio-settings">
          <div id="voiceWrapper">
            <span id="toggleVoice">🎙️</span>
            <select id="voiceSelect" style="display:none;"></select>
          </div>
          <label class="auto-speak-toggle">
            <input type="checkbox" id="autoSpeakToggle" />
            <span class="switch" aria-hidden="true"></span>
            <span class="toggle-text">Auto read questions</span>
          </label>
        </div>
      </div>
    </div>
    <div
      id="rewindOverlay"
      class="overlay-menu"
      aria-hidden="true"
    >
      <div
        class="control-panel rewind-panel"
        id="rewindPanel"
        role="dialog"
        aria-modal="true"
        aria-labelledby="rewindTitle"
        tabindex="-1"
      >
        <button id="closeRewindBtn" class="overlay-close" type="button" aria-label="Close rewind overlay">✕</button>
        <h2 id="rewindTitle" class="overlay-title">Last Round Recap</h2>
        <div id="rewindContent" class="rewind-content" aria-live="polite"></div>
      </div>
    </div>
    <div
      id="categoriesOverlay"
      class="overlay-menu"
      aria-hidden="true"
    >
      <div
        class="control-panel categories-panel"
        role="dialog"
        aria-modal="true"
        aria-labelledby="categoriesTitle"
        tabindex="-1"
      >
        <button id="closeCategoriesBtn" class="overlay-close" type="button" aria-label="Close categories panel">✕</button>
        <h2 class="overlay-title" id="categoriesTitle">Categories</h2>
        <div id="sections" role="group" aria-label="Question categories"></div>
      </div>
    </div>
  </main>

<script src="./questions.js"></script>
<script src="https://cdn.discordapp.com/sdk/embedded-app-sdk.js"></script>
<script type="module">

import anime from 'https://esm.sh/animejs@3.2.1';

const DATA = Array.isArray(window.QUESTION_DATA) ? window.QUESTION_DATA : [];

if (!DATA.length) {
  console.error('Question data failed to load: window.QUESTION_DATA is empty or not an array.');
}

const questionEl = document.getElementById('question');
const categoryEl = document.getElementById('category');
const initialCategoryText = categoryEl ? categoryEl.textContent : '';
const initialQuestionHTML = questionEl ? questionEl.innerHTML : '';
let questionWordTargets = [];
let questionAnimationQueue = Promise.resolve();
let currentQuestionPlainText = questionEl ? questionEl.textContent.replace(/\s+/g, ' ').trim() : '';

const roles = {
  isHost: false,
  isPlayer: false,
};

const discordContext = {
  sdk: null,
  applicationId: new URLSearchParams(window.location.search).get('application_id') || '',
  isReady: false,
  currentUser: null,
  participants: new Map(),
  hostId: null,
  hostName: '',
};

let sharedRevision = 0;
let lastAppliedQuestionSignature = null;
let pendingStatePayload = null;
let pendingStateTimer = null;

function wrapQuestionWords(container, startOffset = '100%') {
  if (!container) return [];
  const nodes = Array.from(container.childNodes);
  const frag = document.createDocumentFragment();
  const targets = [];

  nodes.forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      const parts = node.textContent?.split(/(\s+)/) ?? [];
      parts.forEach((part) => {
        if (!part) return;
        if (/^\s+$/.test(part)) {
          frag.appendChild(document.createTextNode(part));
        } else {
          const outer = document.createElement('span');
          outer.className = 'question-word';
          const inner = document.createElement('span');
          inner.className = 'question-word-inner';
          inner.style.transform = `translateY(${startOffset})`;
          inner.textContent = part;
          outer.appendChild(inner);
          frag.appendChild(outer);
          targets.push(inner);
        }
      });
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const outer = document.createElement('span');
      outer.className = 'question-word';
      const inner = document.createElement('span');
      inner.className = 'question-word-inner';
      inner.style.transform = `translateY(${startOffset})`;
      inner.appendChild(node);
      outer.appendChild(inner);
      frag.appendChild(outer);
      targets.push(inner);
    }
  });

  container.textContent = '';
  container.appendChild(frag);
  return targets;
}

function toPlainQuestionText(html) {
  if (html == null) return '';
  if (typeof html !== 'string') {
    return String(html).replace(/\s+/g, ' ').trim();
  }
  const temp = document.createElement('div');
  temp.innerHTML = html;
  const text = temp.textContent ?? '';
  return text.replace(/\s+/g, ' ').trim();
}

function scaleQuestionText() {
  if (!questionEl) return;

  const card = questionEl.closest('.game-card');
  if (!card) return;

  questionEl.style.fontSize = '';

  const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
  const minSize = rootFontSize * 1;
  const maxSize = rootFontSize * 3.8;

  const currentComputed = parseFloat(getComputedStyle(questionEl).fontSize);
  let fontSize = Number.isFinite(currentComputed) ? currentComputed : minSize;
  fontSize = Math.min(Math.max(fontSize, minSize), maxSize);
  questionEl.style.fontSize = `${fontSize}px`;

  const cardStyles = getComputedStyle(card);
  const paddingTop = parseFloat(cardStyles.paddingTop) || 0;
  const paddingBottom = parseFloat(cardStyles.paddingBottom) || 0;
  const gapValue = parseFloat(cardStyles.rowGap || cardStyles.gap || 0) || 0;

  const children = Array.from(card.children);
  const visibleChildren = children.filter((child) => child.getClientRects().length);
  const totalGaps = gapValue * Math.max(0, visibleChildren.length - 1);
  const otherHeight = visibleChildren.reduce((sum, child) => {
    if (child === questionEl) return sum;
    return sum + child.getBoundingClientRect().height;
  }, 0);

  const computeAvailableHeight = () => {
    const cardHeight = card.clientHeight;
    let space = cardHeight - paddingTop - paddingBottom - totalGaps - otherHeight;
    if (!Number.isFinite(space) || space <= 0) {
      space = Math.max(questionEl.clientHeight, 0);
    }
    return Math.max(space, 120);
  };

  let availableHeight = computeAvailableHeight();

  let iterations = 0;
  let contentHeight = questionEl.scrollHeight;
  let containerHeight = questionEl.clientHeight;
  while (
    (contentHeight > availableHeight + 2 || contentHeight > containerHeight + 2) &&
    fontSize > minSize &&
    iterations < 140
  ) {
    fontSize -= 1;
    questionEl.style.fontSize = `${fontSize}px`;
    availableHeight = computeAvailableHeight();
    contentHeight = questionEl.scrollHeight;
    containerHeight = questionEl.clientHeight;
    iterations += 1;
  }

  iterations = 0;
  contentHeight = questionEl.scrollHeight;
  containerHeight = questionEl.clientHeight;
  while (
    contentHeight < availableHeight - 12 &&
    contentHeight < containerHeight - 12 &&
    fontSize < maxSize &&
    iterations < 80
  ) {
    fontSize += 1;
    questionEl.style.fontSize = `${fontSize}px`;
    availableHeight = computeAvailableHeight();
    contentHeight = questionEl.scrollHeight;
    containerHeight = questionEl.clientHeight;
    if (contentHeight > availableHeight + 2 || contentHeight > containerHeight + 2) {
      fontSize -= 1;
      questionEl.style.fontSize = `${fontSize}px`;
      break;
    }
    iterations += 1;
  }
}

const scheduleQuestionTextScale = (() => {
  let rafId = null;
  return () => {
    if (!questionEl) return;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      rafId = null;
      scaleQuestionText();
    });
  };
})();

if (questionEl) {
  window.addEventListener('resize', scheduleQuestionTextScale);
  if (document.fonts && document.fonts.ready && typeof document.fonts.ready.then === 'function') {
    document.fonts.ready.then(() => scheduleQuestionTextScale()).catch(() => {});
  }
}

if (questionEl) {
  questionWordTargets = wrapQuestionWords(questionEl, '0%');
  scheduleQuestionTextScale();
}

async function animateQuestionSwap(html) {
  if (!questionEl) return;

  if (questionWordTargets.length) {
    try {
      await anime({
        targets: questionWordTargets,
        translateY: ['0%', '-110%'],
        duration: 480,
        easing: 'cubicBezier(.45,.03,.75,.72)',
        delay: anime.stagger(45),
      }).finished;
    } catch (_) {}
  }

  questionEl.innerHTML = html ?? '';
  questionWordTargets = wrapQuestionWords(questionEl, '100%');

  if (questionWordTargets.length) {
    try {
      await anime({
        targets: questionWordTargets,
        translateY: ['100%', '0%'],
        duration: 520,
        easing: 'cubicBezier(.22,1,.36,1)',
        delay: anime.stagger(45),
      }).finished;
    } catch (_) {}
  }

  scheduleQuestionTextScale();
}

function setQuestionContent(html) {
  currentQuestionPlainText = toPlainQuestionText(html);
  questionAnimationQueue = questionAnimationQueue
    .catch(() => {})
    .then(() => animateQuestionSwap(html))
    .then(() => {
      if (!state.autoSpeak || !currentQuestionPlainText) {
        return;
      }
      const currentText = state.current?.text;
      const plainCurrent = currentText ? toPlainQuestionText(currentText) : '';
      if (plainCurrent && plainCurrent === currentQuestionPlainText) {
        speakCurrentQuestion();
      }
    });
  return questionAnimationQueue;
}

function updateQuestionFromState({ force = false } = {}) {
  const actionCluster = document.getElementById('actionCluster');
  const nextBtn = document.getElementById('nextBtn');
  const skipBtn = document.getElementById('skipBtn');
  const speakBtn = document.getElementById('speakBtn');
  const stopSpeakBtn = document.getElementById('stopSpeakBtn');

  const signature = state.current
    ? `${state.current.secIndex ?? ''}:${state.current.qIndex ?? ''}:${state.current.text ?? ''}`
    : 'none';

  if (categoryEl) {
    categoryEl.textContent = state.current?.section || initialCategoryText;
  }

  const shouldUpdate = force || signature !== lastAppliedQuestionSignature;
  if (shouldUpdate) {
    lastAppliedQuestionSignature = signature;
    if (state.current && state.current.text) {
      setQuestionContent(state.current.text);
    } else {
      setQuestionContent(initialQuestionHTML);
    }
  }

  const hasQuestion = Boolean(state.current);
  const controlsActive = hasQuestion && state.current?.raw !== '';
  if (actionCluster) {
    actionCluster.hidden = !controlsActive;
  }
  if (nextBtn) {
    nextBtn.style.display = controlsActive ? 'flex' : 'none';
  }
  if (speakBtn) {
    speakBtn.style.display = controlsActive ? 'flex' : 'none';
  }
  if (stopSpeakBtn) {
    stopSpeakBtn.style.display = controlsActive ? 'flex' : 'none';
  }
  if (skipBtn) {
    skipBtn.style.display = controlsActive && state.players.length ? 'flex' : 'none';
  }
}

/**
 * GROUP DECK — token-based.
 * Tokens:
 *  {PLAYER}  -> randomly chosen acting player
 *  {PAIR}    -> two randomly chosen players joined with "×" (e.g. "Alex × Hiro")
 *  {TRIO}    -> three randomly chosen players
 *  {ALL}     -> literal "everyone" (no assignment)
 * If no token is present, a single {PLAYER} will be auto-assigned.
 * 
 * Categories are horizontal chips at the bottom. Toggle them on/off to include/exclude in the draw.
 */
// ---- State ----
const state = {
  enabled: new Set(DATA.map((_, i) => i)),
  used: DATA.map(() => new Set()),
  players: [],
  playerRegistry: {},
  history: [],
  current: null,
  lastPlayer: null,
  cycle: 1,
  cycle_passed_players: [],
  autoSpeak: false,
};

// Initialize a fresh cycle
function startCycle() {
  state.cycle_passed_players = [];
  updateCycleDisplay();
}

// Pick a single player who hasn't played in the current cycle yet
function pickOne(exclude = []) {
  if (!state.players.length) return null;
  const all_excluded = Array.from(new Set([...exclude, ...state.cycle_passed_players]));
  const pool = state.players.filter(p => !all_excluded.includes(p));
  if (pool.length === 0) {
    if (coversAllPlayers(exclude)) return null;
    // everyone has played → reset the cycle
    state.cycle++;
    startCycle();
    return pickOne(exclude);
  }
  const selected = pool[Math.floor(Math.random() * pool.length)];
  if (selected) {
    state.cycle_passed_players.push(selected);
    updateCycleDisplay();
  }
  return selected;
}

// Pick multiple players (e.g., for {PAIR}, {TRIO}) without repeats
function uniqueSample(n, exclude = []) {
  if (!state.players.length) return [];
  const all_excluded = Array.from(new Set([...exclude, ...state.cycle_passed_players]));
  const pool = state.players.filter(p => !all_excluded.includes(p));
  if (pool.length === 0) {
    if (coversAllPlayers(exclude)) return [];
    state.cycle++;
    startCycle();
    return uniqueSample(n, exclude);
  }
  const shuffled = [...pool].sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, Math.min(n, shuffled.length));
  if (selected.length) {
    state.cycle_passed_players.push(...selected);
    updateCycleDisplay();
  }
  return selected;
}

function updateCycleDisplay() {
  const display = document.getElementById("cycle_players");
  if (!display) return;
  if (!state.players.length) {
    display.innerHTML = `🎉 Welcome!<br><span class="small">Add players to queue up the spotlight.</span>`;
    return;
  }
  const remaining = state.players.filter(
    p => !state.cycle_passed_players.includes(p)
  );
  display.innerHTML =
    remaining.length > 0
      ? `ROUND ${state.cycle}<br><span class="small">Up next: ${remaining.join(", ")}</span>`
      : `✅ Everyone played!<br><span class="small">Round ${state.cycle + 1} loading…</span>`;
}


// ---- Helpers ----
function coversAllPlayers(exclude = []) {
  if (!state.players.length) return true;
  const normalizedExclude = new Set(
    exclude
      .filter(Boolean)
      .map(name => name.toLowerCase())
  );
  return state.players.every(p => normalizedExclude.has(p.toLowerCase()));
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr; 
}
function normalizeName(name) {
  return name.replace(/\s+/g, ' ').trim();
}

function renderPlayersList() {
  const list = document.getElementById('playersList');
  if (!list) return;
  list.innerHTML = '';
  const currentUserId = discordContext.currentUser?.id || null;
  const selfName = currentUserId ? state.playerRegistry?.[currentUserId] : null;
  state.players.forEach((name) => {
    const chip = document.createElement('button');
    chip.type = 'button';
    chip.className = 'player-chip';
    chip.dataset.name = name;
    const isHostChip = Boolean(discordContext.hostName) && name === discordContext.hostName;
    const isSelfChip = Boolean(selfName) && name === selfName;
    if (isHostChip) {
      chip.classList.add('is-host');
      chip.setAttribute('aria-label', `${name} (Host)`);
    } else {
      chip.setAttribute('aria-label', `Remove ${name}`);
    }
    if (isSelfChip) {
      chip.classList.add('is-self');
    }
    chip.title = isHostChip ? `${name} · Host` : `Remove ${name}`;
    if (!roles.isHost) {
      chip.disabled = true;
    }
    chip.setAttribute('role', 'listitem');
    chip.innerHTML = `<span>${name}</span><span class="remove" aria-hidden="true">×</span>`;
    list.appendChild(chip);
  });
}

function refreshPlayers(feedback) {
  state.cycle_passed_players = state.cycle_passed_players.filter((p) =>
    state.players.includes(p)
  );
  if (state.lastPlayer && !state.players.includes(state.lastPlayer)) {
    state.lastPlayer = null;
  }
  if (state.playerRegistry && typeof state.playerRegistry === 'object') {
    const validNames = new Set(state.players);
    Object.entries(state.playerRegistry).forEach(([id, value]) => {
      if (!validNames.has(value)) {
        delete state.playerRegistry[id];
      }
    });
  }
  renderPlayersList();
  const msg = document.getElementById('playersMessage');
  if (msg) {
    if (feedback) {
      msg.textContent = feedback;
    } else if (state.players.length) {
      if (roles.isHost) {
        msg.textContent = 'Ready to draw the next challenge.';
      } else if (roles.isPlayer) {
        msg.textContent = discordContext.hostName
          ? `You\'re in! Waiting for ${discordContext.hostName} to draw.`
          : 'You are in the roster. Await the host for the next move.';
      } else if (discordContext.isReady) {
        msg.textContent = 'Ask the host to start the next round when ready.';
      } else {
        msg.textContent = 'Preview mode · add players from the setup panel.';
      }
    } else {
      if (roles.isHost) {
        msg.textContent = 'No players yet. Add someone to get the game going!';
      } else if (discordContext.isReady) {
        msg.textContent = 'No players yet. Click "Join as Player" to hop in.';
      } else {
        msg.textContent = 'Preview mode · add players from the setup panel.';
      }
    }
  }
  updateCycleDisplay();
  const skipBtn = document.getElementById('skipBtn');
  if (skipBtn && !state.players.length) {
    skipBtn.style.display = 'none';
  }
  if (!state.players.length) {
    const nextBtn = document.getElementById('nextBtn');
    const speakBtn = document.getElementById('speakBtn');
    const stopSpeakBtn = document.getElementById('stopSpeakBtn');
    const actionCluster = document.getElementById('actionCluster');
    if (nextBtn) nextBtn.style.display = 'none';
    if (speakBtn) speakBtn.style.display = 'none';
    if (stopSpeakBtn) stopSpeakBtn.style.display = 'none';
    if (actionCluster) actionCluster.hidden = true;
    scheduleQuestionTextScale();
  }
  const clearBtn = document.getElementById('clearPlayersBtn');
  if (clearBtn) {
    clearBtn.style.display = state.players.length ? 'inline-flex' : 'none';
    clearBtn.disabled = !roles.isHost;
  }
}

function removePlayerByName(name) {
  const index = state.players.findIndex((p) => p === name);
  if (index === -1) return;
  state.players.splice(index, 1);
  Object.entries(state.playerRegistry || {}).forEach(([id, value]) => {
    if (value === name) {
      delete state.playerRegistry[id];
    }
  });
  if (state.players.length === 0) {
    state.cycle = 1;
    startCycle();
  } else {
    state.cycle_passed_players = state.cycle_passed_players.filter((p) => p !== name);
  }
  if (state.current && Array.isArray(state.current.assignees)) {
    state.current.assignees = state.current.assignees.filter((p) => p !== name);
  }
  refreshPlayers(`Removed ${name} from the roster.`);
  syncActivityState();
}

function clearPlayers() {
  if (!state.players.length) {
    refreshPlayers('The roster is already empty. Add new players to start fresh.');
    return;
  }
  state.players = [];
  state.playerRegistry = {};
  state.cycle = 1;
  startCycle();
  if (state.current) {
    state.current.assignees = [];
  }
  refreshPlayers('Roster cleared. Add new players to start fresh.');
  syncActivityState();
}

function resolveTokens(template) {
  let assignees = [];
if (template.includes('{TARGET}')) {
  const target = pickOne(assignees);
  const styled = target ? `<span class="player-name">${target}</span>` : 'someone';
  template = template.replaceAll('{TARGET}', styled);
  if (target) assignees.push(target);
}

if (template.includes('{PAIR}')) {
  const pair = uniqueSample(2, assignees);
  let styled;
  if (pair.length === 2) {
    styled = pair.map(p => `<span class="player-name">${p}</span>`).join(' and ');
  } else if (pair.length === 1) {
    styled = `${pair.map(p => `<span class="player-name">${p}</span>`)[0]} and someone`;
  } else {
    styled = 'someone and someone else';
  }
  template = template.replaceAll('{PAIR}', styled);
  assignees.push(...pair);
}

if (template.includes('{TRIO}')) {
  const trio = uniqueSample(3, assignees);
  let styled;
  if (trio.length === 3) {
    styled = trio.map(p => `<span class="player-name">${p}</span>`).join(', ');
  } else if (trio.length > 0) {
    const rendered = trio.map(p => `<span class="player-name">${p}</span>`).join(', ');
    styled = `${rendered}${rendered ? ', ' : ''}others`;
  } else {
    styled = 'a small group';
  }
  template = template.replaceAll('{TRIO}', styled);
  assignees.push(...trio);
}
if (template.includes('{PLAYER}')) {
  const actor = pickOne(assignees);
  const styled = actor ? `<span class="player-name">${actor}</span>` : 'someone';
  template = template.replaceAll('{PLAYER}', styled);
  if (actor) assignees.unshift(actor);
}
  if (template.includes('{ALL}')) {
    template = template.replaceAll('{ALL}', 'everyone');
  }
  // Assegnazione automatica per QuickPick
  if (
    typeof state.currentSectionTitle === "string" &&
    state.currentSectionTitle.includes("QuickPick") &&
    state.players.length > 0
) {
  const quickPlayer = pickOne();
  assignees = quickPlayer ? [quickPlayer] : [];
}

  // No fallback draw when there are no tokens to resolve
  if (assignees.length === 0) {
    assignees = [];
  }

  assignees = [...new Set(assignees)];
  return { text: template, assignees };
}
function renderSections(){
  const wrap = document.getElementById('sections');
  wrap.innerHTML = '';
  DATA.forEach((sec, idx) => {
    const total = sec.items.length;
    const usedCount = state.used[idx].size;
    const remaining = total - usedCount;
    const chip = document.createElement('button');
    chip.className = 'chip';
    chip.dataset.enabled = state.enabled.has(idx);
    chip.textContent = sec.title;
    const count = document.createElement('span');
    count.className = 'count';
    count.textContent = `(${remaining}/${total})`;
    chip.appendChild(count);
    chip.disabled = !roles.isHost;
    chip.addEventListener('click', () => {
      if (!roles.isHost) return;
      if (state.enabled.has(idx)) state.enabled.delete(idx);
      else state.enabled.add(idx);
      renderSections();
      syncActivityState();
    });
    wrap.appendChild(chip);
  });
}

function ensureUniquePlayerName(base) {
  const normalized = (base || '').trim() || 'Player';
  const seen = new Set(state.players.map((name) => name.toLowerCase()));
  if (!seen.has(normalized.toLowerCase())) {
    return normalized;
  }
  let suffix = 2;
  let candidate = `${normalized} ${suffix}`;
  while (seen.has(candidate.toLowerCase())) {
    suffix += 1;
    candidate = `${normalized} ${suffix}`;
  }
  return candidate;
}

function buildSharedState(overrides = {}) {
  const baseRevision = Number(overrides.revision);
  const nextRevision = Math.max(sharedRevision, Number.isFinite(baseRevision) ? baseRevision : 0) + 1;
  sharedRevision = nextRevision;
  const historyPayload = Array.isArray(state.history)
    ? state.history.map((entry) => ({
        ...entry,
        assignees: Array.isArray(entry.assignees) ? [...entry.assignees] : [],
      }))
    : [];
  const currentPayload = state.current
    ? {
        ...state.current,
        assignees: Array.isArray(state.current.assignees)
          ? [...state.current.assignees]
          : [],
      }
    : null;
  return {
    revision: nextRevision,
    hostId: overrides.hostId ?? discordContext.hostId ?? null,
    hostName: overrides.hostName ?? discordContext.hostName ?? '',
    players: [...state.players],
    playerRegistry: { ...(state.playerRegistry || {}) },
    cycle: state.cycle,
    cyclePassed: [...state.cycle_passed_players],
    lastPlayer: state.lastPlayer,
    history: historyPayload,
    current: currentPayload,
    enabled: Array.from(state.enabled),
    used: state.used.map((set) => Array.from(set)),
  };
}

async function pushSharedState(payload) {
  if (!discordContext.sdk || !discordContext.isReady) {
    return;
  }
  try {
    await discordContext.sdk.commands.setActivityInstanceState({ state: payload });
  } catch (error) {
    console.error('Failed to push activity state', error);
  }
}

function syncActivityState({ immediate = false } = {}) { // State synchronization
  if (!discordContext.isReady || !discordContext.sdk) {
    return;
  }
  pendingStatePayload = buildSharedState();
  if (immediate) {
    if (pendingStateTimer) {
      clearTimeout(pendingStateTimer);
      pendingStateTimer = null;
    }
    const payload = pendingStatePayload;
    pendingStatePayload = null;
    if (payload) {
      pushSharedState(payload);
    }
    return;
  }
  if (pendingStateTimer) {
    return;
  }
  pendingStateTimer = window.setTimeout(() => {
    const payload = pendingStatePayload;
    pendingStatePayload = null;
    pendingStateTimer = null;
    if (payload) {
      pushSharedState(payload);
    }
  }, 80);
}

function composeRoleStatus() {
  if (!discordContext.isReady) {
    return 'Preview mode · offline';
  }
  if (roles.isHost) {
    return 'You are the host';
  }
  if (roles.isPlayer) {
    return discordContext.hostName
      ? `Player · Host: ${discordContext.hostName}`
      : 'Player';
  }
  return discordContext.hostName
    ? `Spectator · Host: ${discordContext.hostName}`
    : 'Spectator';
}

function updateRoleUI({ roleChanged = false } = {}) { // Role management
  if (setupToggleBtn) {
    setupToggleBtn.style.display = roles.isHost ? 'inline-flex' : 'none';
    if (!roles.isHost) {
      closeSetupOverlay({ returnFocus: false });
    }
  }
  if (categoriesToggleBtn) {
    categoriesToggleBtn.style.display = roles.isHost ? 'inline-flex' : 'none';
    if (!roles.isHost) {
      closeCategoriesOverlay({ returnFocus: false });
    }
  }
  if (rewindToggleBtn) {
    rewindToggleBtn.style.display = roles.isHost ? 'inline-flex' : 'none';
    if (!roles.isHost) {
      closeRewindOverlay({ returnFocus: false });
    }
  }
  const startBtnEl = document.getElementById('startBtn');
  if (startBtnEl) startBtnEl.disabled = !roles.isHost;
  const nextBtnEl = document.getElementById('nextBtn');
  if (nextBtnEl) nextBtnEl.disabled = !roles.isHost;
  const skipBtnEl = document.getElementById('skipBtn');
  if (skipBtnEl) skipBtnEl.disabled = !roles.isHost;
  const speakBtnEl = document.getElementById('speakBtn');
  if (speakBtnEl) speakBtnEl.disabled = !roles.isHost;
  const stopSpeakBtnEl = document.getElementById('stopSpeakBtn');
  if (stopSpeakBtnEl) stopSpeakBtnEl.disabled = !roles.isHost;
  const playersInputEl = document.getElementById('playersInput');
  if (playersInputEl) {
    playersInputEl.disabled = !roles.isHost;
    playersInputEl.placeholder = roles.isHost
      ? 'Add player names (press Enter or use commas)'
      : 'Only the host can add names';
  }
  const clearBtnEl = document.getElementById('clearPlayersBtn');
  if (clearBtnEl) {
    clearBtnEl.disabled = !roles.isHost;
  }
  const joinBtn = document.getElementById('joinPlayerBtn');
  if (joinBtn) {
    joinBtn.hidden = roles.isHost;
    const disableJoin = !discordContext.isReady || roles.isPlayer;
    joinBtn.disabled = disableJoin;
    joinBtn.textContent = roles.isPlayer ? 'You are playing' : 'Join as Player';
    joinBtn.setAttribute('aria-disabled', disableJoin.toString());
  }
  const roleStatusEl = document.getElementById('roleStatus');
  if (roleStatusEl) {
    roleStatusEl.textContent = composeRoleStatus();
  }
  if (roleChanged) {
    renderSections();
    renderPlayersList();
  }
}

function evaluateRoles() {
  const previousHost = roles.isHost;
  const previousPlayer = roles.isPlayer;
  if (!discordContext.isReady) {
    roles.isHost = true;
    roles.isPlayer = false;
  } else {
    const currentUserId = discordContext.currentUser?.id || null;
    roles.isHost = Boolean(currentUserId && discordContext.hostId && currentUserId === discordContext.hostId);
    roles.isPlayer = Boolean(currentUserId && state.playerRegistry?.[currentUserId]);
  }
  const roleChanged = previousHost !== roles.isHost || previousPlayer !== roles.isPlayer;
  updateRoleUI({ roleChanged });
  return roleChanged;
}

function applySharedState(shared, { initial = false } = {}) {
  if (!shared || typeof shared !== 'object') {
    return;
  }
  const incomingRevision = Number(shared.revision);
  if (Number.isFinite(incomingRevision) && incomingRevision <= sharedRevision && !initial) {
    return;
  }
  if (Number.isFinite(incomingRevision)) {
    sharedRevision = incomingRevision;
  }
  state.players = Array.isArray(shared.players) ? [...shared.players] : [];
  state.playerRegistry = shared.playerRegistry ? { ...shared.playerRegistry } : {};
  state.cycle = Number.isFinite(shared.cycle) ? shared.cycle : 1;
  state.cycle_passed_players = Array.isArray(shared.cyclePassed) ? [...shared.cyclePassed] : [];
  state.lastPlayer = typeof shared.lastPlayer === 'string' ? shared.lastPlayer : null;
  state.history = Array.isArray(shared.history)
    ? shared.history.map((entry) => ({
        ...entry,
        assignees: Array.isArray(entry.assignees) ? [...entry.assignees] : [],
      }))
    : [];
  state.current = shared.current
    ? {
        ...shared.current,
        assignees: Array.isArray(shared.current.assignees)
          ? [...shared.current.assignees]
          : [],
      }
    : null;
  state.currentSectionTitle = shared.current?.section ?? state.currentSectionTitle ?? '';
  const enabledArray = Array.isArray(shared.enabled) ? shared.enabled : DATA.map((_, idx) => idx);
  state.enabled = new Set(enabledArray);
  state.used = DATA.map((_, idx) => {
    if (!Array.isArray(shared.used)) return new Set();
    const values = Array.isArray(shared.used[idx]) ? shared.used[idx] : [];
    return new Set(values);
  });
  state.cycle_passed_players = state.cycle_passed_players.filter((name) => state.players.includes(name));
  discordContext.hostId = shared.hostId ?? null;
  discordContext.hostName = shared.hostName ?? '';
  evaluateRoles();
  renderSections();
  refreshPlayers();
  updateQuestionFromState({ force: initial });
  if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
    renderRewindContent();
  }
}

function normalizeParticipant(participant) {
  if (!participant) return null;
  const user = participant.user || participant;
  const id = user.id || participant.id || participant.user_id || null;
  if (!id) return null;
  const displayName = (user.global_name || participant.global_name || participant.nick || user.username || '').trim();
  const joinedAtRaw = participant.joined_at || participant.joinedAt || participant.joined_timestamp;
  const joinedAt = joinedAtRaw ? new Date(joinedAtRaw).getTime() : null;
  return {
    id,
    username: user.username || '',
    globalName: user.global_name || '',
    displayName: displayName || `Player ${id.slice(-4)}`,
    joinedAt,
    isCurrent: Boolean(participant.is_current || participant.isSelf || participant.self),
  };
}

function updateParticipantCache(list) {
  if (!Array.isArray(list)) return;
  discordContext.participants.clear();
  list.forEach((entry) => {
    const normalized = normalizeParticipant(entry);
    if (normalized?.id) {
      discordContext.participants.set(normalized.id, normalized);
      if (normalized.isCurrent) {
        discordContext.currentUser = normalized;
      }
    }
  });
  if (discordContext.currentUser && !discordContext.participants.has(discordContext.currentUser.id)) {
    discordContext.participants.set(discordContext.currentUser.id, discordContext.currentUser);
  }
}

function getHostCandidate() {
  if (!discordContext.participants.size) {
    return discordContext.currentUser || null;
  }
  const ordered = Array.from(discordContext.participants.values()).sort((a, b) => {
    if (a.joinedAt && b.joinedAt && a.joinedAt !== b.joinedAt) {
      return a.joinedAt - b.joinedAt;
    }
    return (a.id || '').localeCompare(b.id || '');
  });
  return ordered[0] || null;
}

function evaluateHostClaim({ immediate = false } = {}) { // Host identification
  if (!discordContext.isReady || !discordContext.currentUser) {
    evaluateRoles();
    return false;
  }
  if (discordContext.hostId && discordContext.participants.has(discordContext.hostId)) {
    evaluateRoles();
    return false;
  }
  const candidate = getHostCandidate();
  if (candidate && candidate.id === discordContext.currentUser.id) {
    discordContext.hostId = candidate.id;
    discordContext.hostName = candidate.displayName;
    evaluateRoles();
    syncActivityState({ immediate });
    return true;
  }
  evaluateRoles();
  return false;
}

function handleParticipantsUpdate(participants) {
  if (Array.isArray(participants)) {
    updateParticipantCache(participants);
  }
  if (!discordContext.hostId || !discordContext.participants.has(discordContext.hostId)) {
    evaluateHostClaim({ immediate: true });
  } else {
    evaluateRoles();
  }
  refreshPlayers();
}

function enterOfflineMode() {
  discordContext.isReady = false;
  discordContext.hostId = null;
  discordContext.hostName = 'Offline host';
  roles.isHost = true;
  roles.isPlayer = false;
  updateRoleUI({ roleChanged: true });
  renderSections();
  refreshPlayers();
  updateQuestionFromState({ force: true });
}

function joinAsPlayer() {
  if (!discordContext.isReady || !discordContext.currentUser) {
    return;
  }
  const userId = discordContext.currentUser.id;
  if (!userId) return;
  state.playerRegistry = state.playerRegistry || {};
  if (state.playerRegistry[userId]) {
    refreshPlayers(`You're already in the roster as ${state.playerRegistry[userId]}.`);
    return;
  }
  const baseName = discordContext.currentUser.globalName || discordContext.currentUser.displayName || discordContext.currentUser.username || 'Player';
  const displayName = ensureUniquePlayerName(baseName);
  state.playerRegistry[userId] = displayName;
  state.players.push(displayName);
  const hostClaimed = !discordContext.hostId || !discordContext.participants.has(discordContext.hostId)
    ? evaluateHostClaim({ immediate: true })
    : false;
  if (!hostClaimed) {
    syncActivityState();
    evaluateRoles();
  }
  refreshPlayers(`Joined the roster as ${displayName}.`);
}

async function initDiscordIntegration() {
  if (typeof window.DiscordSDK !== 'function') {
    enterOfflineMode();
    return;
  }
  try {
    discordContext.sdk = new window.DiscordSDK(discordContext.applicationId || undefined); // Discord SDK initialization
    const readyPayload = await discordContext.sdk.ready();
    discordContext.isReady = true;
    const readyUser = normalizeParticipant(readyPayload?.user || readyPayload?.participant || readyPayload?.current_user);
    if (readyUser) {
      discordContext.currentUser = readyUser;
      discordContext.participants.set(readyUser.id, readyUser);
    }
  } catch (error) {
    console.error('Failed to initialize Discord SDK', error);
    enterOfflineMode();
    return;
  }

  discordContext.sdk.subscribe('ACTIVITY_INSTANCE_STATE_UPDATE', ({ state }) => {
    if (state) {
      applySharedState(state);
    }
  }); // State synchronization

  discordContext.sdk.subscribe('ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE', ({ participants }) => {
    handleParticipantsUpdate(participants);
  });

  try {
    const participantsResponse = await discordContext.sdk.commands.getInstanceConnectedParticipants();
    const participants = participantsResponse?.participants ?? participantsResponse ?? [];
    handleParticipantsUpdate(participants);
  } catch (error) {
    console.warn('Unable to fetch participants', error);
  }

  try {
    const stateResponse = await discordContext.sdk.commands.getActivityInstanceState();
    if (stateResponse?.state) {
      applySharedState(stateResponse.state, { initial: true });
      return;
    }
  } catch (error) {
    console.warn('Unable to fetch existing activity state', error);
  }

  evaluateHostClaim({ immediate: true });
  renderSections();
  refreshPlayers();
  updateQuestionFromState({ force: true });
}
function pickRandom(){
  const enabledIndices = [...state.enabled];
  const candidates = [];
  for (const idx of enabledIndices) {
    const sec = DATA[idx];
    for (let i=0; i<sec.items.length; i++) {
      if (!state.used[idx].has(i)) candidates.push({secIndex: idx, qIndex: i});
    }
  }
  if (candidates.length === 0) return null;
  const choice = candidates[Math.floor(Math.random()*candidates.length)];
  return choice;
}
//function typeEffect(element, htmlText, speed = 25) {
//  element.innerHTML = "";
//  let i = 0;
//  const temp = document.createElement("div");
//  temp.innerHTML = htmlText;
//  const fullText = temp.innerHTML;
//  function typeNext() {
//    if (i < fullText.length) {
//      element.innerHTML = fullText.substring(0, i);
//      i++;
//      setTimeout(typeNext, speed);
//    } else {
//      element.innerHTML = fullText;
//    }
//  }
//  typeNext();
// }
function showQuestion(choice){
  window.speechSynthesis.cancel();
  const {secIndex, qIndex} = choice;
  const sec = DATA[secIndex];
  state.currentSectionTitle = sec.title;
  const raw = sec.items[qIndex];
  const { text, assignees } = resolveTokens(raw);
  state.current = { secIndex, qIndex, raw, text, assignees, section: sec.title };
  updateQuestionFromState({ force: true });
}
function nextQuestion(){
  if (!roles.isHost) return;
  window.speechSynthesis.cancel();
  if (
    state.current &&
    Number.isInteger(state.current.secIndex) &&
    Number.isInteger(state.current.qIndex) &&
    state.used[state.current.secIndex]
  ) {
    state.used[state.current.secIndex].add(state.current.qIndex);
    state.history.push(state.current);
    if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
      renderRewindContent();
    }
  }
  const pick = pickRandom();
  if (!pick) {
    state.current = {
      secIndex: null,
      qIndex: null,
      raw: '',
      text: 'No questions left in the selected sections.',
      assignees: [],
      section: 'All questions used',
    };
    updateQuestionFromState({ force: true });
    const nextBtn = document.getElementById('nextBtn');
    const speakBtn = document.getElementById('speakBtn');
    const stopSpeakBtn = document.getElementById('stopSpeakBtn');
    const skipBtn = document.getElementById('skipBtn');
    const actionCluster = document.getElementById('actionCluster');
    if (nextBtn) nextBtn.style.display = 'none';
    if (speakBtn) speakBtn.style.display = 'none';
    if (stopSpeakBtn) stopSpeakBtn.style.display = 'none';
    if (skipBtn) skipBtn.style.display = 'none';
    if (actionCluster) actionCluster.hidden = true;
    scheduleQuestionTextScale();
    renderSections();
    syncActivityState();
    return;
  }
  showQuestion(pick);
  renderSections();
  syncActivityState();
}
function skipQuestion() {
  if (!roles.isHost) return;
  window.speechSynthesis.cancel();
  const current = state.current;
  if (!current || !state.players.length || current.raw === '') return;

  const samePlayer = current.assignees?.[0] || null; // the current player
  let pick;
  let tries = 0;

  do {
    pick = pickRandom();
    if (!pick) break;
    const qText = DATA[pick.secIndex].items[pick.qIndex];

    // avoid questions with DUO ({PAIR}) or EVERYONE ({ALL}) tokens
    if (!qText.includes('{PAIR}') && !qText.includes('{ALL}')) break;

    tries++;
  } while (tries < 50);

  if (!pick) {
    state.current = {
      secIndex: null,
      qIndex: null,
      raw: '',
      text: 'No suitable question found.',
      assignees: samePlayer ? [samePlayer] : [],
      section: state.currentSectionTitle || 'Skip',
    };
    updateQuestionFromState({ force: true });
    const skipBtn = document.getElementById('skipBtn');
    if (skipBtn) skipBtn.style.display = 'none';
    syncActivityState();
    return;
  }

  // Show the new question but keep the same player
  const { secIndex, qIndex } = pick;
  const sec = DATA[secIndex];
  const raw = sec.items[qIndex];
  state.currentSectionTitle = sec.title;

  // resolve tokens but force {PLAYER} to stay on the previous player
  let template = raw;
  const playerMarkup = samePlayer
    ? `<span class="player-name">${samePlayer}</span>`
    : 'someone';
  template = template.replaceAll('{PLAYER}', playerMarkup);
  template = template.replaceAll('{TARGET}', 'someone'); // generic fallback
  template = template.replaceAll('{PAIR}', 'someone and someone else');
  template = template.replaceAll('{TRIO}', 'a small group');
  template = template.replaceAll('{ALL}', 'everyone');

  const assignees = samePlayer ? [samePlayer] : [];
  state.current = { secIndex, qIndex, raw, text: template, assignees, section: sec.title };

  // display without changing the cycle or the roster
  updateQuestionFromState({ force: true });
  syncActivityState();
}


function startGame(){
  if (!roles.isHost) return;
  if (!state.players.length) {
    refreshPlayers('Add at least one player before starting the game.');
    return;
  }
  state.cycle = 1;
  startCycle();
  state.used = DATA.map(()=> new Set());
  state.history = [];
  state.current = null;
  state.lastPlayer = null;
  if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
    renderRewindContent();
  }
  nextQuestion();
  refreshPlayers();
  closeSetupOverlay({ returnFocus: false });

}
function updatePlayers() {
  if (!roles.isHost) return;
  const input = document.getElementById('playersInput');
  if (!input) return;
  const raw = input.value.trim();
  if (!raw) {
    refreshPlayers();
    return;
  }
  const names = raw.split(/[\n,]+/).map(normalizeName).filter(Boolean);
  input.value = '';
  if (!names.length) {
    refreshPlayers();
    return;
  }
  const added = [];
  const skipped = [];
  const seen = new Set(state.players.map((p) => p.toLowerCase()));
  names.forEach((name) => {
    const lower = name.toLowerCase();
    if (!seen.has(lower)) {
      state.players.push(name);
      seen.add(lower);
      added.push(name);
    } else {
      skipped.push(name);
    }
  });
  if (added.length && skipped.length) {
    refreshPlayers(
      `Added to the roster: ${added.join(', ')} · Already in: ${[...new Set(skipped)].join(', ')}`
    );
  } else if (added.length) {
    refreshPlayers(`Added to the roster: ${added.join(', ')}`);
  } else {
    refreshPlayers('Those names are already in the roster.');
  }
  if (added.length) {
    syncActivityState();
  }
}
// ---- Init ----
const controlPanelEl = document.getElementById('controlPanel');
const setupOverlayEl = document.getElementById('setupOverlay');
const categoriesOverlayEl = document.getElementById('categoriesOverlay');
const rewindOverlayEl = document.getElementById('rewindOverlay');
const setupToggleBtn = document.getElementById('setupToggle');
const categoriesToggleBtn = document.getElementById('categoriesToggle');
const rewindToggleBtn = document.getElementById('rewindToggle');
const closeSetupBtn = document.getElementById('closeSetupBtn');
const closeCategoriesBtn = document.getElementById('closeCategoriesBtn');
const closeRewindBtn = document.getElementById('closeRewindBtn');
const rewindPanelEl = document.getElementById('rewindPanel');
const rewindContentEl = document.getElementById('rewindContent');
const categoriesPanelEl = categoriesOverlayEl ? categoriesOverlayEl.querySelector('.categories-panel') : null;

function setOverlayState(overlayEl, toggleBtn, open) {
  if (!overlayEl) return;
  overlayEl.classList.toggle('open', open);
  overlayEl.setAttribute('aria-hidden', (!open).toString());
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', open.toString());
  }
}

function renderRewindContent() {
  if (!rewindContentEl) return;
  rewindContentEl.innerHTML = '';
  const lastEntry = state.history.length ? state.history[state.history.length - 1] : null;

  if (!lastEntry) {
    const empty = document.createElement('p');
    empty.className = 'rewind-empty';
    empty.textContent = 'No previous question yet.';
    rewindContentEl.appendChild(empty);
    return;
  }

  const playersPara = document.createElement('p');
  playersPara.className = 'rewind-meta';
  const playersLabel = document.createElement('strong');
  const players = Array.isArray(lastEntry.assignees)
    ? lastEntry.assignees.filter((name) => !!name)
    : [];
  playersLabel.textContent = players.length > 1 ? 'Players:' : 'Player:';
  playersPara.appendChild(playersLabel);
  playersPara.appendChild(document.createTextNode(' '));

  if (players.length) {
    const playersWrap = document.createElement('span');
    playersWrap.className = 'rewind-players';
    players.forEach((name) => {
      const badge = document.createElement('span');
      badge.textContent = name;
      playersWrap.appendChild(badge);
    });
    playersPara.appendChild(playersWrap);
  } else {
    const everyoneWrap = document.createElement('span');
    everyoneWrap.className = 'rewind-players';
    const badge = document.createElement('span');
    badge.textContent = 'Everyone';
    everyoneWrap.appendChild(badge);
    playersPara.appendChild(everyoneWrap);
  }
  rewindContentEl.appendChild(playersPara);

  if (lastEntry.section) {
    const sectionPara = document.createElement('p');
    sectionPara.className = 'rewind-meta';
    const sectionLabel = document.createElement('strong');
    sectionLabel.textContent = 'Category:';
    sectionPara.appendChild(sectionLabel);
    sectionPara.appendChild(document.createTextNode(` ${lastEntry.section}`));
    rewindContentEl.appendChild(sectionPara);
  }

  const questionPara = document.createElement('p');
  questionPara.className = 'rewind-question';
  questionPara.textContent = toPlainQuestionText(lastEntry.text) || '—';
  rewindContentEl.appendChild(questionPara);
}

function closeSetupOverlay({ returnFocus = true } = {}) {
  if (!setupOverlayEl || !setupOverlayEl.classList.contains('open')) return;
  setOverlayState(setupOverlayEl, setupToggleBtn, false);
  if (returnFocus && setupToggleBtn) {
    setupToggleBtn.focus({ preventScroll: true });
  }
}

function closeCategoriesOverlay({ returnFocus = true } = {}) {
  if (!categoriesOverlayEl || !categoriesOverlayEl.classList.contains('open')) return;
  setOverlayState(categoriesOverlayEl, categoriesToggleBtn, false);
  if (returnFocus && categoriesToggleBtn) {
    categoriesToggleBtn.focus({ preventScroll: true });
  }
}

function closeRewindOverlay({ returnFocus = true } = {}) {
  if (!rewindOverlayEl || !rewindOverlayEl.classList.contains('open')) return;
  setOverlayState(rewindOverlayEl, rewindToggleBtn, false);
  if (returnFocus && rewindToggleBtn) {
    rewindToggleBtn.focus({ preventScroll: true });
  }
}

function openSetupOverlay() {
  if (!setupOverlayEl) return;
  if (categoriesOverlayEl && categoriesOverlayEl.classList.contains('open')) {
    closeCategoriesOverlay({ returnFocus: false });
  }
  if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
    closeRewindOverlay({ returnFocus: false });
  }
  setOverlayState(setupOverlayEl, setupToggleBtn, true);
  window.requestAnimationFrame(() => {
    const input = document.getElementById('playersInput');
    if (input) {
      input.focus({ preventScroll: true });
    } else if (controlPanelEl) {
      controlPanelEl.focus({ preventScroll: true });
    }
  });
}

function openCategoriesOverlay() {
  if (!categoriesOverlayEl) return;
  if (setupOverlayEl && setupOverlayEl.classList.contains('open')) {
    closeSetupOverlay({ returnFocus: false });
  }
  if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
    closeRewindOverlay({ returnFocus: false });
  }
  setOverlayState(categoriesOverlayEl, categoriesToggleBtn, true);
  window.requestAnimationFrame(() => {
    const firstChip = categoriesOverlayEl.querySelector('#sections button');
    if (firstChip) {
      firstChip.focus({ preventScroll: true });
    } else if (categoriesPanelEl) {
      categoriesPanelEl.focus({ preventScroll: true });
    }
  });
}

function openRewindOverlay() {
  if (!rewindOverlayEl) return;
  if (setupOverlayEl && setupOverlayEl.classList.contains('open')) {
    closeSetupOverlay({ returnFocus: false });
  }
  if (categoriesOverlayEl && categoriesOverlayEl.classList.contains('open')) {
    closeCategoriesOverlay({ returnFocus: false });
  }
  renderRewindContent();
  setOverlayState(rewindOverlayEl, rewindToggleBtn, true);
  window.requestAnimationFrame(() => {
    if (rewindPanelEl) {
      rewindPanelEl.focus({ preventScroll: true });
    }
  });
}

if (setupToggleBtn && setupOverlayEl) {
  setupToggleBtn.addEventListener('click', () => {
    if (setupOverlayEl.classList.contains('open')) {
      closeSetupOverlay();
    } else {
      openSetupOverlay();
    }
  });
}

if (categoriesToggleBtn && categoriesOverlayEl) {
  categoriesToggleBtn.addEventListener('click', () => {
    if (categoriesOverlayEl.classList.contains('open')) {
      closeCategoriesOverlay();
    } else {
      openCategoriesOverlay();
    }
  });
}

if (rewindToggleBtn && rewindOverlayEl) {
  rewindToggleBtn.addEventListener('click', () => {
    if (rewindOverlayEl.classList.contains('open')) {
      closeRewindOverlay();
    } else {
      openRewindOverlay();
    }
  });
}

if (closeSetupBtn) {
  closeSetupBtn.addEventListener('click', () => closeSetupOverlay());
}

if (closeCategoriesBtn) {
  closeCategoriesBtn.addEventListener('click', () => closeCategoriesOverlay());
}

if (closeRewindBtn) {
  closeRewindBtn.addEventListener('click', () => closeRewindOverlay());
}

if (setupOverlayEl) {
  setupOverlayEl.addEventListener('click', (event) => {
    if (event.target === setupOverlayEl) {
      closeSetupOverlay();
    }
  });
}

if (categoriesOverlayEl) {
  categoriesOverlayEl.addEventListener('click', (event) => {
    if (event.target === categoriesOverlayEl) {
      closeCategoriesOverlay();
    }
  });
}

if (rewindOverlayEl) {
  rewindOverlayEl.addEventListener('click', (event) => {
    if (event.target === rewindOverlayEl) {
      closeRewindOverlay();
    }
  });
}

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    if (rewindOverlayEl && rewindOverlayEl.classList.contains('open')) {
      closeRewindOverlay();
      event.preventDefault();
    } else if (categoriesOverlayEl && categoriesOverlayEl.classList.contains('open')) {
      closeCategoriesOverlay();
      event.preventDefault();
    } else if (setupOverlayEl && setupOverlayEl.classList.contains('open')) {
      closeSetupOverlay();
      event.preventDefault();
    }
  }
});

const startButton = document.getElementById('startBtn');
if (startButton) {
  startButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    startGame();
  });
}

const nextButton = document.getElementById('nextBtn');
if (nextButton) {
  nextButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    nextQuestion();
  });
}

const playersInputEl = document.getElementById('playersInput');
if (playersInputEl) {
  playersInputEl.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
      event.preventDefault();
      if (!roles.isHost) return;
      updatePlayers();
    }
  });
}

const playersListEl = document.getElementById('playersList');
if (playersListEl) {
  playersListEl.addEventListener('click', (event) => {
    if (!roles.isHost) return;
    const chip = event.target.closest('.player-chip');
    if (!chip) return;
    removePlayerByName(chip.dataset.name);
  });
}

const clearPlayersButton = document.getElementById('clearPlayersBtn');
if (clearPlayersButton) {
  clearPlayersButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    clearPlayers();
  });
}

const joinPlayerBtnEl = document.getElementById('joinPlayerBtn');
if (joinPlayerBtnEl) {
  joinPlayerBtnEl.addEventListener('click', () => {
    if (joinPlayerBtnEl.disabled) return;
    joinAsPlayer();
  });
}

updateRoleUI();
renderSections();
refreshPlayers();
initDiscordIntegration();

// ---- Voice Select ----
function populateVoiceList() {
  const select = document.getElementById("voiceSelect");
  const voices = speechSynthesis.getVoices();
  select.innerHTML = "";
  voices.forEach((voice) => {
    const option = document.createElement("option");
    option.value = voice.name;
    option.textContent = voice.name + " (" + voice.lang + ")";
    if (voice.default) option.textContent += " [default]";
    // Auto-select a preferred sample voice if it matches
    if (voice.name === "Google UK English Male" && voice.lang === "en-GB") {
      option.selected = true;
    }
    select.appendChild(option);
  });
}
speechSynthesis.onvoiceschanged = populateVoiceList;
populateVoiceList();

// ---- TTS ----
function speakCurrentQuestion() {
  if (typeof window === 'undefined' || !('speechSynthesis' in window) || typeof SpeechSynthesisUtterance === 'undefined') {
    return;
  }

  const text = currentQuestionPlainText || (questionEl ? questionEl.innerText : '');
  if (!text || !text.trim()) return;

  window.speechSynthesis.cancel();

  const utterance = new SpeechSynthesisUtterance(text);
  const voiceSelect = document.getElementById('voiceSelect');
  const selectedVoice = voiceSelect ? voiceSelect.value : '';
  if (selectedVoice) {
    const voices = speechSynthesis.getVoices();
    const voice = voices.find((v) => v.name === selectedVoice);
    if (voice) {
      utterance.voice = voice;
    }
  }
  utterance.lang = utterance.voice?.lang || 'en-US';
  utterance.rate = 1;
  utterance.pitch = 1;

  window.speechSynthesis.speak(utterance);
}

const speakButton = document.getElementById('speakBtn');
if (speakButton) {
  speakButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    speakCurrentQuestion();
  });
}
const stopSpeakButton = document.getElementById('stopSpeakBtn');
if (stopSpeakButton) {
  stopSpeakButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    window.speechSynthesis.cancel();
  });
}
const autoSpeakToggle = document.getElementById('autoSpeakToggle');
if (autoSpeakToggle) {
  autoSpeakToggle.addEventListener('change', () => {
    state.autoSpeak = autoSpeakToggle.checked;
    const container = autoSpeakToggle.closest('.auto-speak-toggle');
    if (container) {
      container.classList.toggle('is-active', state.autoSpeak);
    }
    if (state.autoSpeak) {
      const currentText = state.current?.text;
      const plainCurrent = currentText ? toPlainQuestionText(currentText) : '';
      if (plainCurrent && plainCurrent === currentQuestionPlainText) {
        speakCurrentQuestion();
      }
    } else {
      window.speechSynthesis.cancel();
    }
  });
  const container = autoSpeakToggle.closest('.auto-speak-toggle');
  if (container) {
    container.classList.toggle('is-active', autoSpeakToggle.checked);
  }
}
document.getElementById("toggleVoice").addEventListener("click", () => {
  const select = document.getElementById("voiceSelect");
  if (select.style.display === "none") {
    select.style.display = "inline-block";
  } else {
    select.style.display = "none";
  }
});
const skipButton = document.getElementById('skipBtn');
if (skipButton) {
  skipButton.addEventListener('click', () => {
    if (!roles.isHost) return;
    skipQuestion();
  });
}

</script>
</body>
</html>
